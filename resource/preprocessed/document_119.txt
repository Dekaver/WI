Boolean Convert To Int Error (Beginning Java forum at Coderanch)
Search...
FAQs
Subscribe
Pie
FAQs
Recent topics
Flagged topics
Hot topics
Best topics
Search...
Search within Beginning Java
Search Coderanch
Advance search
Google search
Register / Login
Post Reply
Bookmark Topic
Watch Topic
New Topic
programming forums
Java
Mobile
Certification
Databases
Caching
Books
Engineering
Micro Controllers
OS
Languages
Paradigms
IDEs
Build Tools
Frameworks
Application Servers
Open Source
This Site
Careers
Other
Pie Elite
all forums
this forum made possible by our volunteer staff, including ...
Marshals:
Campbell Ritchie
Paul Clapham
Ron McLeod
paul wheaton
Devaka Cooray
Sheriffs:
Jeanne Boyarsky
Tim Cooke
Liutauras Vilda
Saloon Keepers:
Tim Moores
Tim Holloway
Stephan van Hulst
Carey Brown
Piet Souris
Bartenders:
salvin francis
Mikalai Zaikin
Himai Minh
Forum:
Beginning Java
Boolean Convert To Int Error
Brian Bykenhaal
Ranch Hand
Posts: 57
posted 7 years ago
Number of slices to send:
Optional 'thank-you' note:
Send
Hello Java Ranch,
I have been working on a TicTacToe console game in Java. I have a error and hope to learn more about java and how to fix this error. Boolean needs to be converted to Int. I have tried to add code to convert but got more errors.
Exception in thread "main" java.lang.RuntimeException: Uncompilable source code - incompatible types: boolean cannot be converted to int
at javaapplication46.tic.JavaApplication46Ticjava.main(JavaApplication46Ticjava.java:74)
Java Result: 1
BUILD SUCCESSFUL (total time: 4 seconds)
Ubaldo Robledo
Greenhorn
Posts: 22
I like...
posted 7 years ago
Number of slices to send:
Optional 'thank-you' note:
Send
Can you put the code, to see how you are doing it
pepe pecas pica papas con un pico,
con un pico pepe pecas pica papas..
Marc Cracco
Ranch Hand
Posts: 80
1
posted 7 years ago
1
Number of slices to send:
Optional 'thank-you' note:
Send
Some languages have implicit conversion from int to boolean or vice versa. Java doesn't.
You could use
int val = b? 1 : 0;
SCJP 6 [ My stuff ]
Winston Gutkowski
Bartender
Posts: 10777
71
I like...
posted 7 years ago
Number of slices to send:
Optional 'thank-you' note:
Send
Brian Bykenhaal wrote:I have been working on a TicTacToe console game in Java. I have a error and hope to learn more about java and how to fix this error. Boolean needs to be converted to Int. I have tried to add code to convert but got more errors.
Well, that's always a bad move. Never add code until you know what the problem is.
However, without seeing your code (and only the code that is causing the error, please), we can't help much. I'd care to bet, though, that you're assigning a boolean to an integer.
Winston
"Leadership is nature's way of removing morons from the productive flow" - Dogbert
Articles by Winston can be found here
Ubaldo Robledo
Greenhorn
Posts: 22
I like...
posted 7 years ago
Number of slices to send:
Optional 'thank-you' note:
Send
Marc Cracco wrote:Some languages have implicit conversion from int to boolean or vice versa. Java doesn't.
You could use
int val = b? 1 : 0;
using 1 to true and 0 to false.
pepe pecas pica papas con un pico,
con un pico pepe pecas pica papas..
Marc Cracco
Ranch Hand
Posts: 80
1
posted 7 years ago
Number of slices to send:
Optional 'thank-you' note:
Send
Ubaldo Robledo wrote:
using 1 to true and 0 to false.
Was that a question or were you agreeing?
SCJP 6 [ My stuff ]
Winston Gutkowski
Bartender
Posts: 10777
71
I like...
posted 7 years ago
Number of slices to send:
Optional 'thank-you' note:
Send
Marc Cracco wrote:Was that a question or were you agreeing?
I think Ubaldo was clarifying. Think about it.
Winston
"Leadership is nature's way of removing morons from the productive flow" - Dogbert
Articles by Winston can be found here
Ubaldo Robledo
Greenhorn
Posts: 22
I like...
posted 7 years ago
Number of slices to send:
Optional 'thank-you' note:
Send
Marc Cracco wrote:
Was that a question or were you agreeing?
I was agreeing, cause sometimes code is confusing. (no this one) but im new and i understand how hard is sometime to catch some info.
pepe pecas pica papas con un pico,
con un pico pepe pecas pica papas..
Marc Cracco
Ranch Hand
Posts: 80
1
posted 7 years ago
Number of slices to send:
Optional 'thank-you' note:
Send
Ubaldo Robledo wrote:
I was agreeing, cause sometimes code is confusing. (no this one) but im new and i understand how hard is sometime to catch some info.
Gotcha, well here is a little more information on the line of code I wrote, it's called a Ternary Operator, more specific checkout the Java Usage Section.
SCJP 6 [ My stuff ]
Jesper de Jong
Java Cowboy
Posts: 16084
88
I like...
posted 7 years ago
Number of slices to send:
Optional 'thank-you' note:
Send
Brian Bykenhaal wrote:Exception in thread "main" java.lang.RuntimeException: Uncompilable source code - incompatible types: boolean cannot be converted to int
The message "Uncompilable source code" suggests to me that not all your class files are up-to-date - you might be mixing *.class files from a previous version with other *.class files in which you changed things. Try re-compiling the whole project.
Jesper's Blog - Pluralsight Author Page
Campbell Ritchie
Marshal
Posts: 72762
317
posted 7 years ago
Number of slices to send:
Optional 'thank-you' note:
Send
Brian Bykenhaal wrote: . . .
Exception in thread "main" java.lang.RuntimeException: Uncompilable source code - . . .
Welcome to the Ranch
You only ever get that sort of error message from an IDE; the rest of the message has a NetBeansâ€‘y style. Many of us round here think it is not a good idea to start learning on an IDE, but if you have got used to your IDE, you should never try to run uncompiled code. There should be a red mark against the code where the compiler error occurred, and you might be able to get more information by hovering on the red mark with the mouse or clicking it.
Brian Bykenhaal
Ranch Hand
Posts: 57
posted 7 years ago
Number of slices to send:
Optional 'thank-you' note:
Send
Hey
Wow thanks for the information yeah I am pretty Green at Java and only messed with java scripts in Html. I want to make a Three in a row Game as you all know. I wanted to add something like the Tic Tac Toe named TTT Cosnole Non OO2P.java at this url webpage
The problem is I can now get the program to run. I do not know where to go with this code. It is more complex then the last really simple game I made from a YouTube channel a while ago.
Error with my code
I hit run yes in my net beans and I see my board and then I type any of the spaces. I used rows and columns in like battle ship style. So I type in 1 1 for row 1 column 1 and then I get a error like this
If you think it is a compile error I will see if I can compile but I never compiled this with Command prompt. So I have no class file with this code yet.
package javaapplication46.tic;
import java.util.Scanner;
public class JavaApplication46Ticjava {
public static int[][] gameboard;
public static final int EMPTY = 0;
public static final int NOUGHT = -1;
public static final int CROSS = 1;
static void set(int val, int row, int col) throws
IllegalArgumentException {
if (gameboard[row][col] == EMPTY) gameboard[row][col] = val;
else throw new IllegalArgumentException("Player already there!");
}
static void displayBoard() {
for( int r = 0; r < gameboard.length; r++) {
System.out.print("|");
for (int c = 0; c < gameboard[r].length; c++) {
switch(gameboard[r][c]) {
case NOUGHT:
System.out.print("O");
break;
case CROSS:
System.out.print("X");
break;
default:
//EMPTY
System.out.print(" ");
}
System.out.print("|");
}
System.out.println("\n-------\n");
}
}
static void createBoard(int row, int col) {
gameboard = new int[row][col];
}
static boolean winOrTie() {
//Determine whether X or O won or there is a tie
return;
}
/**
* @param args the command line arguments
*/
public static void main(String[] args) {
Scanner scan = new Scanner(System.in);
createBoard(3,3);
int turn = 0;
int playerVal;
int outcome = -2;
boolean b = true;
boolean boolVal = true;
if( boolVal )
playerVal = 1;
else
playerVal = 0;
do {
displayBoard();
playerVal = (turn % 2 == 0)? NOUGHT : CROSS;
if (playerVal == NOUGHT) System.out.println("\n-O's turn-");
else System.out.println("\n-X's turn-");
System.out.print("Enter row and column:");
try {
set(playerVal, scan.nextInt(), scan.nextInt());
} catch (IllegalArgumentException ex) {System.err.println(ex);}
turn ++;
outcome = winOrTie();
} while ( outcome == -2 );
displayBoard();
switch (outcome) {
case NOUGHT:
System.out.println("O wins!");
break;
case CROSS:
System.out.println("X wins!");
break;
case EMPTY:
System.out.println("Tie");
break;
}
}
}
Campbell Ritchie
Marshal
Posts: 72762
317
posted 7 years ago
Number of slices to send:
Optional 'thank-you' note:
Send
Don't use numbers to represent the different players. Use an enumerated type.
Marc Cracco
Ranch Hand
Posts: 80
1
posted 7 years ago
Number of slices to send:
Optional 'thank-you' note:
Send
Couple of things off the bat.
winOrTie() can't return nothing.
If you don't know what code will go in there for now either return true or false.
outcome = winOrTie();
since outcome is an int you can give it a value from a boolean, for now I commented it out.
I don't know if I had my braces off or you but after cleaning that up I got the game to run.
Next I wouldn't throw an Exception if a slot is taken.
Show messaging and repoll the user for a square to play.
SCJP 6 [ My stuff ]
Brian Bykenhaal
Ranch Hand
Posts: 57
posted 7 years ago
Number of slices to send:
Optional 'thank-you' note:
Send
Thanks for the help I got it to run and it understood the numbers I typed in. The problem seems to be the my rows and columns I put in 1 1 and got the middle space. I wanted 1 1 is the top left corner. Any Idea what went wrong?
System.out.println("This move at (" + (row + 1) + "," + (col + 1)
+ ") is not valid. Try again...");
}
} while (!validInput);
// repeat until input is valid
}
Campbell Ritchie
Marshal
Posts: 72762
317
posted 7 years ago
Number of slices to send:
Optional 'thank-you' note:
Send
Nothing went wrong; the top left is (0, 0), rather than (1, 1).
Marc Cracco
Ranch Hand
Posts: 80
1
posted 7 years ago
Number of slices to send:
Optional 'thank-you' note:
Send
To make it more user friendly you could take the inputs and remove 1 to make it match the array index which start at 0.
For the enum talked about you could use
private enum Player {
ONE("X"),
TWO("O");
private String piece;
private Player(String piece) {
this.piece = piece;
}
public String getPieceValue() {
return piece;
}
}
Also consider having the main do while loop check a boolean called gameComplete or something like that.
Near the end of the loop call a method (i.e. checkGameStatus()) that could check to see if someone one, and or if the game is tied.
If the game is finished update the gameComplete variable to true and set a variable called winner with the proper player.
These are just ideas on how I would do it.
SCJP 6 [ My stuff ]
Brian Bykenhaal
Ranch Hand
Posts: 57
posted 7 years ago
Number of slices to send:
Optional 'thank-you' note:
Send
I had it working a little then I messed it up and and saved it. This is what I have now.
package javaapplication46.tic;
import java.util.Scanner;
public class JavaApplication46Ticjava {
public static int[][] gameboard;
public static final int EMPTY = 0;
public static final int NOUGHT = -1;
public static final int CROSS = 1;
static void set(int val, int row, int col) throws
IllegalArgumentException {
if (gameboard[row][col] == EMPTY) gameboard[row][col] = val;
else throw new IllegalArgumentException("Player already there!");
}
static void displayBoard() {
for( int r = 0; r < gameboard.length; r++) {
System.out.print("|");
for (int c = 0; c < gameboard[r].length; c++) {
switch(gameboard[r][c]) {
case NOUGHT:
System.out.print("O");
break;
case CROSS:
System.out.print("X");
break;
default:
//EMPTY
System.out.print(" ");
}
System.out.print("|");
}
System.out.println("\n-------\n");
}
}
static void createBoard(int row, int col) {
gameboard = new int[row][col];
}
static boolean winOrTie() {
//Determine whether X or O won or there is a tie
return true;
}
/**
* @param args the command line arguments
*/
public static void main(String[] args) {
Scanner scan = new Scanner(System.in);
createBoard(3,3);
int turn = 0;
int playerVal;
int outcome = -2;
boolean b = true;
boolean boolVal = true;
if( boolVal )
playerVal = 1;
else
playerVal = 0;
do {
displayBoard();
playerVal = (turn % 2 == 0)? NOUGHT : CROSS;
if (playerVal == NOUGHT) System.out.println("\n-O's turn-");
else System.out.println("\n-X's turn-");
System.out.print("Enter row and column:");
try {
set(playerVal, scan.nextInt(), scan.nextInt());
} catch (IllegalArgumentException ex) {System.err.println(ex);}
turn ++;
outcome = winOrTie();
return false;
} while ( outcome == -2 );
displayBoard();
switch (outcome) {
case NOUGHT:
System.out.println("O wins!");
break;
case CROSS:
System.out.println("X wins!");
break;
case EMPTY:
System.out.println("Tie");
break;
}
}
}
Brian Bykenhaal
Ranch Hand
Posts: 57
posted 7 years ago
Number of slices to send:
Optional 'thank-you' note:
Send
Thanks for the help like I said I got the program to run. I did what you told me and put in 1 1. I then got the middle of the board. I tried to fix it and saved it to run it with the changes and ended up wishing I never changed after I got it to work. If you can tell me from what I have on my last code post what is it that I am doing wrong I will run it and save. I like the enum idea I watch a youtube video and the programmer used enum.
Marc Cracco
Ranch Hand
Posts: 80
1
posted 7 years ago
Number of slices to send:
Optional 'thank-you' note:
Send
Take a look below, still a lot missing but hopefully it helps.
import java.util.Scanner;
public class Main {
public static String[][] gameboard;
// The whole game should be wrapped in a game object and for each play
// create an instance. This variable belong in the instance.
private static boolean gameComplete = false;
private static Player winner = null;
static boolean set(String val, int row, int col) throws
IllegalArgumentException {
if (gameboard[row - 1][col - 1] == null) {
gameboard[row - 1][col - 1] = val;
return true;
}
return false;
}
static void displayBoard() {
System.out.println("\n-------\n");
for (int r = 0; r < gameboard.length; r++) {
System.out.print("|");
for (int c = 0; c < gameboard[r].length; c++) {
if (gameboard[r][c] == null) {
System.out.print(" ");
} else {
System.out.print(gameboard[r][c]);
}
System.out.print("|");
}
System.out.println("\n-------\n");
}
}
static void createBoard(int row, int col) {
gameboard = new String[row][col];
}
static void checkGameStatus() {
/*
* TODO this method needs to check game status and update two params,
* gameComplete and winner.
*/
// first iterate through the board looking for nulls, if there are some
// we still have valid moves.
// this updates the gameComplete variable.
// next create some logic to check for possible wins.
// this updates the winner variable.
}
/**
* @param args the command line arguments
*/
public static void main(String[] args) {
Scanner scan = new Scanner(System.in);
createBoard(3, 3);
int turn = 0;
boolean b = true;
Player[] players = { Player.ONE, Player.TWO };
int currentPlayerIndex = 0;
do {
displayBoard();
currentPlayerIndex = (turn % 2 == 0) ? 0 : 1;
System.out.println(String.format("\n-%s's turn-",
players[currentPlayerIndex].getPieceValue()));
System.out.print("Enter row and column:");
boolean validMove = false;
do {
System.out.print("Enter row and column:");
validMove = set(players[currentPlayerIndex].getPieceValue(),
scan.nextInt(), scan.nextInt());
if (!validMove) {
System.out
.println("Sorry, you've entered an invalid move.");
}
} while (validMove == false);
checkGameStatus();
turn++;
} while (!gameComplete);
if (winner != null) {
System.out
.println(String.format("%s wins!", winner.getPieceValue()));
} else {
System.out.println("Tie");
}
}
private enum Player {
ONE("X"),
TWO("O");
private String piece;
private Player(String piece) {
this.piece = piece;
}
public String getPieceValue() {
return piece;
}
}
}
SCJP 6 [ My stuff ]
Brian Bykenhaal
Ranch Hand
Posts: 57
posted 7 years ago
Number of slices to send:
Optional 'thank-you' note:
Send
Thanks the java works great! I still have some issues like when I put in a wrong number. I would like to no have a error. I have seen code like below used. Maybe a else statment.
System.out.println("This move at (" + (row + 1) + "," + (col + 1)
+ ") is not valid. Try again...");
}
} while (!validInput);
// repeat until input is valid
}
Marc Cracco
Ranch Hand
Posts: 80
1
posted 7 years ago
Number of slices to send:
Optional 'thank-you' note:
Send
Brian Bykenhaal wrote:Thanks the java works great! I still have some issues like when I put in a wrong number. I would like to no have a error. I have seen code like below used. Maybe a else statment.
System.out.println("This move at (" + (row + 1) + "," + (col + 1)
+ ") is not valid. Try again...");
}
} while (!validInput);
// repeat until input is valid
}
I'm not sure I understand what you want to do. Do you want it to show an error or not?
Right now it does and queries the user again.
What would you want the flow to be?
Have you figured out the logic for finding a winner yet?
Have you considered creating this over multiple classes like mentioned in the commnents? It's a little more complex but makes more sense.
You could create a TicTacToe class.
The main method would then create an instance of that class and then when the game is finished it could either quit or let the user create a new one.
It would also stop having those static method which isn't the best way to do this.
SCJP 6 [ My stuff ]
Brian Bykenhaal
Ranch Hand
Posts: 57
posted 7 years ago
Number of slices to send:
Optional 'thank-you' note:
Send
Hey thanks
I am working on either adding a scanner like you said or if statements to check to see if I have a winner. The static is fine for now I will be remaking this game with modified code from this version in the near future. For now I think I will be staying true to the very simple version of the console game. Like on the like given. I have updated code below but first is some code I was messing with. The project is coming along nicely. Once I learn how to find a winner I should be happy with the code. Like you said a Scanner would work best for checking to see if there is a winner. Below is done with a if statement.
"currentState" after the player with "thePlayer" has placed on
(currentRow, currentCol). */
public static void updateGame(int theSeed, int currentRow, int currentCol) {
if (hasWon(theSeed, currentRow, currentCol)) {
// check if winning move
currentState = (theSeed == CROSS) ? Player 1 CROSS_WON : Player 2 NOUGHT_WON;
} else if (isDraw()) {
// check for draw
currentState = DRAW;
}
import java.util.Scanner;
public class Good {
public static String[][] gameboard;
// The whole game should be wrapped in a game object and for each play
// create an instance. This variable belong in the instance.
private static boolean gameComplete = false;
private static Player winner = null;
static boolean set(String val, int row, int col) throws
IllegalArgumentException {
if (gameboard[row - 1][col - 1] == null) {
gameboard[row - 1][col - 1] = val;
return true;
}
return false;
}
static void displayBoard() {
System.out.println("\n-------\n");
for (int r = 0; r < gameboard.length; r++) {
System.out.print("|");
for (int c = 0; c < gameboard[r].length; c++) {
if (gameboard[r][c] == null) {
System.out.print(" ");
} else {
System.out.print(gameboard[r][c]);
}
System.out.print("|");
}
System.out.println("\n-------\n");
}
}
static void createBoard(int row, int col) {
gameboard = new String[row][col];
}
static void checkGameStatus() {
}
public static void main(String[] args) {
Scanner scan = new Scanner(System.in);
createBoard(3, 3);
int turn = 0;
boolean b = true;
Player[] players = { Player.ONE, Player.TWO };
int currentPlayerIndex = 0;
do {
displayBoard();
currentPlayerIndex = (turn % 2 == 0) ? 0 : 1;
System.out.println(String.format("\n-%s's turn-",
players[currentPlayerIndex].getPieceValue()));
System.out.print("Enter row and column:");
boolean validMove = false;
do {
System.out.print("Enter row and column:");
validMove = set(players[currentPlayerIndex].getPieceValue(),
scan.nextInt(), scan.nextInt());
if (!validMove) {
System.out
.println("Sorry, you've entered an invalid move.");
}
} while (validMove == false);
checkGameStatus();
turn++;
} while (!gameComplete);
if (winner != null) {
System.out
.println(String.format("%s wins!", winner.getPieceValue()));
} else {
System.out.println("Tie");
}
}
private enum Player {
ONE("X"),
TWO("O");
private String piece;
private Player(String piece) {
this.piece = piece;
}
public String getPieceValue() {
return piece;
}
}
}
Campbell Ritchie
Marshal
Posts: 72762
317
posted 7 years ago
Number of slices to send:
Optional 'thank-you' note:
Send
Brian Bykenhaal wrote: . . .
// The whole game should be wrapped in a game object
. . .
No, the whole game should be a game object. You should design your entire code with that in mind. You should have objects for the game, the board, the squares, and the players. If not more.
Your design with all those static keywords is inconsistent with that aim, I am afraid.
Brian Bykenhaal
Ranch Hand
Posts: 57
posted 7 years ago
Number of slices to send:
Optional 'thank-you' note:
Send
This is an example of the a game I would like to make the only difference is I would like to use the code I have already created. I like that this version works really well try it out. Thanks I will keep that in mind and in the future I will have Tic Tac Toe game with different classes. Thanks again.
import java.util.Scanner;
/**
* Tic-Tac-Toe: Two-player console, non-graphics, non-OO version.
* All variables/methods are declared as static (belong to the class)
*
in the non-OO version.
*/
public class Brian___{
// Name-constants to represent the seeds and cell contents
public static final int EMPTY = 0;
public static final int CROSS = 1;
public static final int NOUGHT = 2;
// Name-constants to represent the various states of the game
public static final int PLAYING = 0;
public static final int DRAW = 1;
public static final int CROSS_WON = 2;
public static final int NOUGHT_WON = 3;
// The game board and the game status
public static final int ROWS = 3, COLS = 3; // number of rows and columns
public static int[][] board = new int[ROWS][COLS]; // game board in 2D array
//
containing (EMPTY, CROSS, NOUGHT)
public static int currentState;
// the current state of the game
// (PLAYING, DRAW, CROSS_WON, NOUGHT_WON)
public static int currentPlayer; // the current player (CROSS or NOUGHT)
public static int currntRow, currentCol; // current seed's row and column
public static Scanner in = new Scanner(System.in); // the input Scanner
/** The entry main method (the program starts here) */
public static void main(String[] args) {
// Initialize the game-board and current status
initGame();
// Play the game once
do {
playerMove(currentPlayer); // update currentRow and currentCol
updateGame(currentPlayer, currntRow, currentCol); // update currentState
printBoard();
// Print message if game-over
if (currentState == CROSS_WON) {
System.out.println("'X' won! Bye!");
} else if (currentState == NOUGHT_WON) {
System.out.println("'O' won! Bye!");
} else if (currentState == DRAW) {
System.out.println("It's a Draw! Bye!");
}
// Switch player
currentPlayer = (currentPlayer == CROSS) ? NOUGHT : CROSS;
} while (currentState == PLAYING); // repeat if not game-over
}
/** Initialize the game-board contents and the current states */
public static void initGame() {
for (int row = 0; row < ROWS; ++row) {
for (int col = 0; col < COLS; ++col) {
board[row][col] = EMPTY;
// all cells empty
}
}
currentState = PLAYING; // ready to play
currentPlayer = CROSS;
// cross plays first
}
/** Player with the "theSeed" makes one move, with input validation.
Update global variables "currentRow" and "currentCol". */
public static void playerMove(int theSeed) {
boolean validInput = false;
// for input validation
do {
if (theSeed == CROSS) {
System.out.print("Player 'X', enter your move (row[1-3] column[1-3]): ");
} else {
System.out.print("Player 'O', enter your move (row[1-3] column[1-3]): ");
}
int row = in.nextInt() - 1;
// array index starts at 0 instead of 1
int col = in.nextInt() - 1;
if (row >= 0 && row < ROWS && col >= 0 && col < COLS && board[row][col] == EMPTY) {
currntRow = row;
currentCol = col;
board[currntRow][currentCol] = theSeed;
// update game-board content
validInput = true;
// input okay, exit loop
} else {
System.out.println("This move at (" + (row + 1) + "," + (col + 1)
+ ") is not valid. Try again...");
}
} while (!validInput);
// repeat until input is valid
}
/** Update the "currentState" after the player with "theSeed" has placed on
(currentRow, currentCol). */
public static void updateGame(int theSeed, int currentRow, int currentCol) {
if (hasWon(theSeed, currentRow, currentCol)) {
// check if winning move
currentState = (theSeed == CROSS) ? CROSS_WON : NOUGHT_WON;
} else if (isDraw()) {
// check for draw
currentState = DRAW;
}
// Otherwise, no change to currentState (still PLAYING).
}
/** Return true if it is a draw (no more empty cell) */
// TODO: Shall declare draw if no player can "possibly" win
public static boolean isDraw() {
for (int row = 0; row < ROWS; ++row) {
for (int col = 0; col < COLS; ++col) {
if (board[row][col] == EMPTY) {
return false;
// an empty cell found, not draw, exit
}
}
}
return true;
// no empty cell, it's a draw
}
/** Return true if the player with "theSeed" has won after placing at
(currentRow, currentCol) */
public static boolean hasWon(int theSeed, int currentRow, int currentCol) {
return (board[currentRow][0] == theSeed
// 3-in-the-row
&& board[currentRow][1] == theSeed
&& board[currentRow][2] == theSeed
|| board[0][currentCol] == theSeed
// 3-in-the-column
&& board[1][currentCol] == theSeed
&& board[2][currentCol] == theSeed
|| currentRow == currentCol
// 3-in-the-diagonal
&& board[0][0] == theSeed
&& board[1][1] == theSeed
&& board[2][2] == theSeed
|| currentRow + currentCol == 2
// 3-in-the-opposite-diagonal
&& board[0][2] == theSeed
&& board[1][1] == theSeed
&& board[2][0] == theSeed);
}
/** Print the game board */
public static void printBoard() {
for (int row = 0; row < ROWS; ++row) {
for (int col = 0; col < COLS; ++col) {
printCell(board[row][col]); // print each of the cells
if (col != COLS - 1) {
System.out.print("|");
// print vertical partition
}
}
System.out.println();
if (row != ROWS - 1) {
System.out.println("-----------"); // print horizontal partition
}
}
System.out.println();
}
/** Print a cell with the specified "content" */
public static void printCell(int content) {
switch (content) {
case EMPTY:
System.out.print("
"); break;
case NOUGHT: System.out.print(" O "); break;
case CROSS:
System.out.print(" X "); break;
}
}
}
Brian Bykenhaal
Ranch Hand
Posts: 57
posted 7 years ago
Number of slices to send:
Optional 'thank-you' note:
Send
Hey
I am back working on my Java game, I seem to be lost to what I am missing for the game to Scan for a winner. As someone posted earlier Scanner could scan to find a winner. This sounds great the way I have it now I am using checkGameStatus(). I understand a while loop is better then hard coding the entire win part of the game.
Marc Cracco
Ranch Hand
Posts: 80
1
posted 7 years ago
Number of slices to send:
Optional 'thank-you' note:
Send
Why would you use scanner to scan for a winner?
You need to write some logic that's going to look at the board.
There needs to be some logic as to what to check and in what order.
1) Is there a winner?2) Is there more moves available?
For one you need to figure out what is considered a move and write code to check for it.
If one is false then go to two which can just check if there are any empty slots left.
SCJP 6 [ My stuff ]
Brian Bykenhaal
Ranch Hand
Posts: 57
posted 7 years ago
Number of slices to send:
Optional 'thank-you' note:
Send
This is what I am working on after a Youtube channel I used boolean flags for logic. This seems to be the easiest way to check for a winner because I do not need to hard code everything. I plan on implementing this code below into my game so that a winner can be found. Thanks again for scanner I was told that I could use a scanner to check for a winner but will not use the scanner to check for a winner. Thanks again.
public static boolean checkForWinner(char[][] b)
{
// checkForWinner() method determines if a pattern of data stored
// in the 2D array Flag shows what player has won the game.
boolean flag = false;
boolean flag1 = false;
boolean flag2 = false;
boolean flag3 = false;
boolean flag4 = false;
// checks the char of each row for matching data
for (int i = 0; i <= 2; i++)
{
if ((b[i][0] == b[i][1] && b[i][1] == b[i][2]) && b[i][2] != ' ')
flag1 = true;
}
// checks the char of each column for matching data
for (int j = 0; j <= 2; j++)
{
if ((b[0][j] == b[1][j] && b[1][j] == b[2][j]) && b[2][j] != ' ')
flag2 = true;
}
// checks the char of one diagonal for matching data
if ((b[0][0] == b[1][1] && b[1][1] == b[2][2]) && b[2][2] != ' ')
flag3 = true;
// checks the char of the other diagonal for matching data
if ((b[0][2] == b[1][1] && b[1][1] == b[2][0]) && b[2][0] != ' ')
flag4 = true;
// checks the previous conditions are true
if (flag1 == true || flag2 == true || flag3 == true || flag4 == true)
flag = true;
// returns true if a winner was found, but returns false is no winner
return flag;
}
Campbell Ritchie
Marshal
Posts: 72762
317
posted 7 years ago
Number of slices to send:
Optional 'thank-you' note:
Send
Brian Bykenhaal wrote: . . . Scanner could scan to find a winner. . . .
That seems unlikely, as Marc Gracco has already said.
Marc Cracco
Ranch Hand
Posts: 80
1
posted 7 years ago
Number of slices to send:
Optional 'thank-you' note:
Send
Why are you using all these different flags.
It's not like you're telling the winner "You want by going across" so why not use 1 flag?
SCJP 6 [ My stuff ]
Brian Bykenhaal
Ranch Hand
Posts: 57
posted 7 years ago
Number of slices to send:
Optional 'thank-you' note:
Send
I have tried using a char[][] array as well to store the 'x' and 'O', and flags but still its not working all the time. I will work on cutting down the flags to just one. To check the change in the board. Then to find a winner thanks for the help.
Marc Cracco
Ranch Hand
Posts: 80
1
posted 7 years ago
Number of slices to send:
Optional 'thank-you' note:
Send
Are you using an IDE or coding in a text editor, if you're using a text editor see below....
Back in the days when I was using a text editor I got used to using a lot of system.out for debugging.
A nice clean way I use to do this is as follow.
public class MyClass {
public static boolean isDebug = false;
....
....
public void myMethod() {
String result = doSomething();
if (isDebug) {
System.out.println("This is my debug code... result = " + result);
}
}
}
You can use that if statement all over your code and leave it there.
When you're debugging a problem turn the boolean to true, the rest of the time leave it as false.
SCJP 6 [ My stuff ]
Brian Bykenhaal
Ranch Hand
Posts: 57
posted 7 years ago
Number of slices to send:
Optional 'thank-you' note:
Send
Hey
Great I have Net Beans and notepad++ I am in Net Beans thanks I have my Boolean set to true for debugging. I have been using the features with NetBean to help clean up my code I like this feature a lot.
I have logic this is my hardcoded version. As you said I had to many flags so I will go with something easier.
"I hope"
import java.util.Scanner;
public class Good {
public static String[][] gameboard;
private static boolean gameComplete = false;
private static Player winner = null;
static boolean set(String val, int row, int col) throws
IllegalArgumentException {
if (gameboard[row - 1][col - 1] == null) {
gameboard[row - 1][col - 1] = val;
return true;
}
return false;
}
static void displayBoard() {
System.out.println("\n-------\n");
for (int r = 0; r < gameboard.length; r++) {
System.out.print("|");
for (int c = 0; c < gameboard[r].length; c++) {
if (gameboard[r][c] == null) {
System.out.print(" ");
} else {
System.out.print(gameboard[r][c]);
}
System.out.print("|");
}
System.out.println("\n-------\n");
}
}
static void createBoard(int row, int col) {
gameboard = new String[row][col];
}
static void checkGameStatus() {
}
public static void main(String[] args) {
Scanner scan = new Scanner(System.in);
createBoard(3, 3);
int turn = 0;
boolean b = true;
Player[] players = { Player.ONE, Player.TWO };
int currentPlayerIndex = 0;
do {
displayBoard();
currentPlayerIndex = (turn % 2 == 0) ? 0 : 1;
System.out.println(String.format("\n-%s's turn-",
players[currentPlayerIndex].getPieceValue()));
System.out.print("Enter row and column:");
boolean validMove = false;
do {
System.out.print("Enter row and column:");
validMove = set(players[currentPlayerIndex].getPieceValue(),
scan.nextInt(), scan.nextInt());
if (!validMove) {
System.out
.println("Sorry, you've entered an invalid move.");
}
} while (validMove == false);
checkGameStatus();
turn++;
} while (!gameComplete);
if (winner != null) {
System.out
.println(String.format("%s wins!", winner.getPieceValue()));
} else {
System.out.println("Tie");
}
}
private Object[][] board;
private boolean checkRow(int r, String symbol) {
throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
}
private boolean checkColumn(int c, String symbol) {
throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
}
private boolean checkMajorDiag(int r, int c, String symbol) {
throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
}
private boolean checkMinorDiag(int r, int c, String symbol) {
throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
}
private enum Player {
ONE("X"),
TWO("O");
private String piece;
private Player(String piece) {
this.piece = piece;
}
public String getPieceValue() {
return piece;
}
}
public String getWinner(int r, int c, String symbol)
{
if (checkRow(r, symbol) || checkColumn(c, symbol) ||
checkMajorDiag(r, c, symbol) || checkMinorDiag(r, c, symbol))
{
return(symbol);
}
else
{
return(' ');
}
}
public boolean getWinner(int symbol)
{
return (
(board[0][0].equals(symbol) && board[0][1].equals(symbol) && board[0][2].equals(symbol)) ||
(board[1][0].equals(symbol) && board[1][1].equals(symbol) && board[1][2].equals(symbol)) ||
(board[2][0].equals(symbol) && board[2][1].equals(symbol) && board[2][2].equals(symbol)) ||
(board[0][0].equals(symbol) && board[1][0].equals(symbol) && board[2][0].equals(symbol)) ||
(board[0][1].equals(symbol) && board[1][1].equals(symbol) && board[2][1].equals(symbol)) ||
(board[0][2].equals(symbol) && board[1][2].equals(symbol) && board[2][2].equals(symbol)) ||
(board[0][0].equals(symbol) && board[1][1].equals(symbol) && board[2][2].equals(symbol)) ||
(board[0][2].equals(symbol) && board[1][1].equals(symbol) && board[2][0].equals(symbol))
);
}
}
}
}
Marc Cracco
Ranch Hand
Posts: 80
1
posted 7 years ago
Number of slices to send:
Optional 'thank-you' note:
Send
public String getWinner(int r, int c, String symbol) {
you're returning a string yet you're return statement does not always
return(' ');
//should be
return(" " );
//or probably better to return
return null;
You also have two differnet variables, one is a board and one is a gameboard.
Copying code from elsewhere is not going to work if you don't look at your variables.
By copying you also ended with tons of extra }
You also have empty methods like checkRow and such which seem redundant since you also have getWinner()
SCJP 6 [ My stuff ]
Brian Bykenhaal
Ranch Hand
Posts: 57
posted 7 years ago
Number of slices to send:
Optional 'thank-you' note:
Send
Thanks for the crash course I plan to take your advice and have started again one the Java Tic Tac Toe. I have it all planned out this time around. This way I can stay to one path like using a array to check for a winner and a try catch black to catch exeptions to my set method.
Campbell Ritchie
Marshal
Posts: 72762
317
posted 7 years ago
Number of slices to send:
Optional 'thank-you' note:
Send
Marc Cracco wrote: . . .
. . .
//or probably better to return
return null;
. . .
Not convinced. There is something wrong with a method which has to return null. Also that appears inappropriate use of strings. You should have a Player class, which will obviously have two instances O and X. You should only call any winner's method when the game is finished and you have not got a tie.s
Brian Bykenhaal
Ranch Hand
Posts: 57
posted 7 years ago
Number of slices to send:
Optional 'thank-you' note:
Send
Hey I made some logic for my game I try both ways and the if statement seams right. I think I need to prompt the game to stop when I have a winner. I do not know how to do this yet but I can share what I have done already. I was going to remake the program and ran into trouble.
I am working on making some logic to check for winners and to see if it is a tie. I was able to research this and found that two ways are most popular the 0-9 method and the [1] [1] to [3] [3] I like the second because I have been using that method all along. I was planning a lot of brute force coding in the form of if statements. What do you think am I on the right track? Thanks again
You showed up just in time for the waffles! And this tiny ad:
Building a Better World in your Backyard by Paul Wheaton and Shawn Klassen-Koop
https://coderanch.com/wiki/718759/books/Building-World-Backyard-Paul-Wheaton
reply
reply
Bookmark Topic
Watch Topic
New Topic
Boost this thread!
Similar Threads
Strings
java 1.5 for loop problem
Could someone explain what is wrong with my set methods?
anyone know how I could fix the errors in my code?
How to modify this program to use & display 1s and 0s instead of true and false?
More...
current ranch time (not your local time) is May 31, 2021 11:41:44
all times are in ranch time: GMT-6 in summer, GMT-7 in winter
contact us | advertise |
| Powered by JForum | copyright Â© 1998-2021 paul wheaton, missoula, MT